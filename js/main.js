// Generated by CoffeeScript 1.6.3
(function() {
  var CityAroundResearch, Geolocation, GeolocationProvider, WeatherDetector;

  CityAroundResearch = (function() {
    function CityAroundResearch(geolocation, proximity) {
      var searchParams, that;
      this.geolocation = geolocation;
      this.proximity = proximity;
      searchParams = {
        lat: this.geolocation.getLat(),
        long: this.geolocation.getLong(),
        results: 3,
        proximity: this.proximity
      };
      that = this;
      $.get('http://nik94.free.fr/LycornPublishing/search/city', searchParams, function(data) {
        if (typeof console !== "undefined" && console !== null) {
          console.log(data);
        }
        return window.updateSearchResults(data);
      }, 'JSON');
    }

    return CityAroundResearch;

  })();

  if (!window.lycorn) {
    window.lycorn = {};
  }

  window.lycorn.CityAroundResearch = CityAroundResearch;

  Geolocation = (function() {
    function Geolocation(lat, long, cityName, country, type) {
      this.lat = lat;
      this.long = long;
      this.cityName = cityName;
      this.country = country;
      this.type = type != null ? type : 'ip';
    }

    Geolocation.prototype.getLat = function() {
      return this.lat;
    };

    Geolocation.prototype.getLong = function() {
      return this.long;
    };

    Geolocation.prototype.getCityName = function() {
      return this.cityName;
    };

    Geolocation.prototype.country = function() {
      return this.country;
    };

    return Geolocation;

  })();

  if (!window.lycorn) {
    window.lycorn = {};
  }

  window.lycorn.Geolocation = Geolocation;

  GeolocationProvider = (function() {
    function GeolocationProvider() {
      this.positionAvailableEvent = 'locationAvailable';
      this.doc = jQuery(document);
      this.geolocationOpts = {
        enableHighAccuracy: true,
        maximumAge: 0,
        timeout: 30
      };
      if (navigator.geolocation) {
        this.searchWithGPS();
      } else {
        this.searchWithoutGPS();
      }
    }

    GeolocationProvider.prototype.searchWithGPS = function() {
      var that;
      that = this;
      navigator.geolocation.getCurrentPosition(function(position) {
        var geocodingParams, lat, long, provider;
        provider = that;
        lat = position.coords.latitude;
        long = position.coords.longitude;
        geocodingParams = {
          latlng: lat + ',' + long,
          sensor: true
        };
        return $.get('http://maps.googleapis.com/maps/api/geocode/json', geocodingParams, function(data) {
          var city, component, country, type, _i, _len, _ref;
          for (component in results.address_components) {
            _ref = component.types;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              type = _ref[_i];
              if (type === "locality") {
                city = component.short_name;
              }
              if (type === "country") {
                country = component.short_name;
              }
            }
          }
          provider.buildLocation(lat, long, city, country, 'GPS');
        }, 'JSON');
      }, this.searchWithoutGPSAsFallback(this), this.geolocationOpts);
    };

    GeolocationProvider.prototype.searchWithoutGPSAsFallback = function(scope) {
      var context, temp;
      context = scope;
      return temp = function() {
        return context.searchWithoutGPS.apply(context);
      };
    };

    GeolocationProvider.prototype.searchWithoutGPS = function() {
      var provider;
      provider = this;
      $.get('http://ipinfo.io/json', function(data) {
        var lat, long, _tmp;
        _tmp = data.loc.split(',');
        lat = _tmp[0];
        long = _tmp[1];
        provider.buildLocation(lat, long, data.city, data.country, 'IP');
      }, 'JSON');
    };

    GeolocationProvider.prototype.buildLocation = function(lat, long, city, country, type) {
      var location;
      location = new lycorn.Geolocation(lat, long, city, country, type);
      this.doc.trigger(this.positionAvailableEvent, location);
    };

    if (!window.lycorn) {
      window.lycorn = {};
    }

    window.lycorn.GeolocationProvider = GeolocationProvider;

    return GeolocationProvider;

  })();

  window.myApp = angular.module('myApp', []);

  window.myApp.factory('updateSearchResults', function($window, $q, $rootScope) {
    var deferred;
    deferred = $q.defer();
    $window.updateSearchResults = function(obj) {
      deferred.resolve(obj);
      return $rootScope.$apply();
    };
    return deferred.promise;
  });

  window.myApp.controller('SearchResults', function($scope, updateSearchResults) {
    updateSearchResults.then(function(locations) {
      $scope.locations = locations;
      return $(document).trigger('searchResultsRendered');
    });
    $scope.locations = [];
    return $scope.getMetroClass = function(index) {
      var availableClasses;
      availableClasses = ['panel-primary', 'panel-success', 'panel-warning', 'panel-danger', 'panel-info'];
      return availableClasses[index % 5];
    };
  });

  WeatherDetector = (function() {
    function WeatherDetector(cityData) {
      var requestParams, that;
      this.cityData = cityData;
      this.providerUrl = 'http://api.previmeteo.com/06eee7d1c20d0bb49d9e909acf4ddcb0/ig/api';
      if (typeof console !== "undefined" && console !== null) {
        console.log('New weather request for', this.cityData);
      }
      requestParams = {
        weather: this.cityData.zipCode + ',' + this.cityData.country,
        hl: 'fr',
        res: 'json'
      };
      that = this;
      if (typeof console !== "undefined" && console !== null) {
        console.log(this.providerUrl);
      }
      $.get(this.providerUrl, requestParams, function(data) {
        return typeof console !== "undefined" && console !== null ? console.log('Retrieved weather for', that.cityData, data) : void 0;
      }, 'JSON');
    }

    return WeatherDetector;

  })();

  if (!window.lycorn) {
    window.lycorn = {};
  }

  window.lycorn.WeatherDetector = WeatherDetector;

}).call(this);
